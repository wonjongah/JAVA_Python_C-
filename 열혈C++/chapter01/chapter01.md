#### 1-1 printf와 scanf를 대신하는 입출력 방식



- 헤더파일 선언문 #include <iostream>



C언어에서는 입출력을 위한 printf 함수와 scanf 함수의 호출을 목적으로 헤더파일 <stdio.h>를 포함했다면, C++에서는 입출력 관련 일을 하기 위해서 #include <iostream>을 추가해야 한다.

std, cout, endl 같은 것을 사용하기 위해 필요하다.



- std::cout과 << 연산자를 이용한 출력



```C++
std::cout << '출력대상';
```



'출력대상' 위치에는 무엇이든 올 수 있다. C언어의 printf 함수와 달리 출력 포맷을 지정하지 않아도 데이터의 성격에 따라 적절한 출력이 이루어진다.



- << 연상자를 이용한 출력 대상의 연이은 표현과 개행



<< 연산자를 이용하면 다음과 같이 둘 이상의 출력 대상을 연이어서 출력할 수도 있다.



```C++
std::cout<<'출력대상1' << '출력대상2' << '출력대상3';
```



<< 연산자를 이용한 std::endl의 출력은 개행으로 이어진다.



- 데이터의 입력에 사용하는 std::cin과 >> 연산자



키보드로부터 데이터 입력을 받기 위해서는 아래와 같은 형식을 취하면 된다.



```c++
std::cin >> '변수';
```



'변수'의 위치에는 키보드로부터 입력받은 데이터를 저장할 변수의 이름이 오면 된다. 위는 즉 키보드로부터 데이터 하나를 입력받아서 변수에 저장하라는 의미이다.

C++에서는 데이터의 입력도 출력과 마찬가지로 별도의 포맷 지정이 필요 없기 때문에 데이터 타입에 맞는 변수 입력이 진행된다.



```C++
std::cin >> '변수1' >> '변수2';
```



다음과 같은 구조로 연속적인 데이터 입력을 요구할 수도 있다. 첫 번째 변수와 두 번째 변수의 경계는 탭, 스페이스바, Enter 같은 공백에 의해 나눠진다.



- C++의 지역변수 선언



C++의 지역변수 선언은 함수 내 어디든 삽입이 가능하다. 



- for 문 내의 변수 선언 및 초기화



```c++
for(int i = val1 + 1; i < val2; i++){
...
}
```



와 같이 for 문 내에 변수를 선언과 동시에 초기화할 수 있다.



#### 1-2 함수 오버로딩



C언어에서는 동일한 이름의 함수가 정의되는 것을 컴파일 오류를 내며 허용하지 않는다. 그러나 함수 호출 시 전달되는 인자를 통해서 호출하고자 하는 함수의 구분이 가능하기 때문에 매개변수의 선언 형태가 다르다면, 동일한 이름의 함수 정의를 허용할 수 있다. 이런 C++은 이를 허용하며, 함수 오버로딩(Function Overloading)이라 부른다.

C++은 허용하고 C는 허용하지 않는 이유는 C++은 호출할 함수를 찾을 때 '함수의 이름', '매개변수의 선언' 두 가지 정보를 동시에 활용하기 때문이다. 반면 C언어는 함수의 이름만 이용해서 호출 대상을 찾기 때문에 함수의 오버로딩이 불가능하다.



- 함수 오버로딩 예



```c++
int MyFunc(char c){...}
int MyFunc(int n){...}
```



함수 오버로딩이 가능하려면 매개변수의 선언이 달라야 한다. 위는 매개변수의 자료형이 다르므로, 자료형을 통해 호출할 함수의 구분이 가능하기 때문에 오버로딩이 가능하다.



```c++
int MyFunc(int n){...}
int MyFunc(int n1, int n2){...}
```



마찬가지로 매개변수의 개수가 다른 경우도 호출할 함수의 구분이 가능하기 때문에 위의 경우도 함수의 오버로딩이 가능하다.



즉, 함수의 오버로딩이 가능기 위해선 매개변수의 자료형 또는 개수가 달라야 한다.



```c++
void MyFunc(int n){...}
int MyFunc(int n){...}
```



반면 위의 예는 반환형이 다르다. 하지만 반환형은 함수 호출 시, 호출되는 함수를 구분하는 기준이 될 수 없기 때문에 위는 컴파일 오류로 이어진다.



#### 1-3 매개변수의 디폴트 값



- 매개변수에 설정하는 '디폴트 값'의 의미



함수의 매개변수를 다음의 형태로 선언하는 것이 가능하다.



```c++
int Func(int num = 7){
return num+1;
}
```



위의 Func의 매개변수 선언은 int num = 7이다. 이 의미는 함수 호출 시 인자를 전달하지 않으면 7이 전달된 것으로 간주하겠다는 뜻이다. 따라서 Func();과 Func(7); 이 두 호출문은 완전히 동일하다.

매개변수에 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자 전달이 가능하다.  그리고 전달되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.



```C++
int Adder(int num1 = 1, int num2 = 2);

int Adder(int num1, int num2){
    return num1 + num2;
}
```



매개변수의 디폴트 값은 함수의 원형 선언에만 위치시켜야 한다.



- 부분적 디폴트 값 설정



```c++
int Func(int num1, int num2 = 5, int num3 = 7){...}
```



일부분만 디폴트 값으로 지정하면, Func(10); // Func(10, 5, 7);

Func(10, 20); // Func(10, 20, 7);

과 같은 형태로 함수 호출이 가능하다.



하지만, 반드시 오른쪽 매개변수의 디폴트 값부터 채우는 형태로 정의해야 한다.



```c++
int Func(int num1 = 3, int num2); // 에러
```



함수에 전달되는 인자가 왼쪽에서부터 오른쪽으로 채워지기 때문이다.