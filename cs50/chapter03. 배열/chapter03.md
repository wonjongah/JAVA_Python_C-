#### 01. 컴파일링



```c
#include <stdio.h>

int main(void){
printf("hello, world\n");
}
```

main 함수는 프로그램의 시작점으로 실행 버튼을 클릭하는 것과 같다.

printf 출력 함수를 사용하기 위해 stdio.h 라이브러리가 필요해 include했다.

정확히 stdio.h는 헤더파일로 C언어로 작성되어 있고, 파일명이 .h로 끝난다. 

이 파일에는 printf 함수의 프로토타입이 있어서 Clang 컴파일러가 프로그램을 컴파일할 때 printf가 무엇인지 알려주는 역할을 한다.

```c
clang -o hello hello.c
```

의 명령을 통해 컴파일을 한다.

cs50 라이브러리를 사용한 프로그램을 컴파일 할 때는 clang에 또 하나의 프로그램(-lcs50)이 필요하다.

```c
clang -o hello hello.c -lcs50
```

이 명령어는 clang에게 cs50 라이브러리에 있는 모든 0과 1들을 여기에 연결하라는 의미이다.

더 간단히 make 프로그램을 실행하면 이런 모든 컴파일 과정을 자동으로 처리할 수 있다.

make나 clang을 사용해서 프로그램을 실행할 때 아래 네 개의 단계를 거친다.

1. 전처리
2. 컴파일링
3. 어셈블링
4. 링킹



- 전처리(Precompile)



컴파일의 전체 과정 중 첫 번째 단계이다. 전처리기에 의해 수행되며, #으로 시작되는 C 소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려준다.



- 컴파일(Compile)



전처리기가 전처리한 소스 코드를 생성하고 나면 다음 단계는 컴파일이다. 컴파일러라고 불리는 프로그램은 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일한다.

어셈블리는 C보다 연산의 종류가 적지만, 여러 연산이 함께 사용되면 C에서 할 수 있는 모든 것을 수행할 수 있다.



- 어셈블(Assemble)



소스가 어셈블리 코드로 변환되면, 다음 단계인 어셈블 단계로 어셈블리 코드를 오브젝트 코드로 변환시키는 것이다. 컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 0과 1들로 바꿔주는 작업이다.

이 변환 작업은 어셈블러라는 프로그램이 수행한다. 소스코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면 컴파일 작업은 여기서 끝이 나지만, 그렇지 않은 경우에는 링크라 불리는 단계가 추가된다.



- 링크(Link)



만약 프로그램이 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크라는 컴파일의 마지막 단계가 필요하다. 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다. 



이 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성된다.



#### 02. 디버깅



- 버그와 디버깅



버그는 코드에 들어있는 오류이다. 버그로 인해 프로그램의 실행에 실패하거나 프로그래머가 원하는 대로 동작하지 않게 된다. 

디버깅(debugging)은 코드에 있는 버그를 식별하고 고치는 과정이다.

프로그래머는 디버거라는 프로그램을 사용해 디버깅을 한다.



- 디버깅의 기본



디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움을 준다.

프로그램이 멈추는 특정 지점을 중지점이라고 한다.

또한 프로그래머가 프로그램을 한번에 한 행씩 실행할 수 있게 해주기 때문에 프로그래머는 프로그램이 내리는 모든 결정을 단계별로 따라갈 수 있게 된다.



- debug50



소스코드에서 직접 브레이크 포인트를 지정하고 소스파일을 컴파일한 후에 "debug50 파일명"으로 실행하면, 오른쪽 패널을 통해 변수의 값을 확인하기 위해 브레이크 포인트로부터 한 줄씩 코드를 실행해 볼 수 있다.



#### 03. 코드의 디자인



- check50



check50 프로그램을 이용하면 과제를 잘 수행했는지 자동으로 검사가 가능하다.



- style50



style50 프로그램은 코드가 심미적으로 잘 작성되었는지 검사할 수 있다.

많은 회사의 사내에서 코드를 작성할 때 특정한 스타일 가이드를 따르도록 한다.

여러 사람들이 코드를 작성하고, 서로 불필요한 오해를 없애고자, 그리고 코드를 이해하는 데 드는 비용을 최소화하기 때문이다.



- 고무오리



앞의 프로그램들이 존재하지 않거나, 있어도 디버깅에 도움이 되지 않을 경우 고무오리와 같이 무언가 대상이 되는 물체를 앞에 두고, 내가 작성한 코드를 한 줄 한 줄 말로 설명해주는 과정을 거쳐볼 수 있다.



#### 04. 배열(1)



C에는 여러 자료형이 있고, 각각의 자료형은 서로 다른 크기의 메모리를 차지한다.

bool : 1byte

char : 1byte

int : 4byte

float : 4byte

long : 8byte

double : 8byte

string : ? 바이트

컴퓨터 안에는 RAM이라는 물리적 칩이 메모리 역할을 한다.

램 속 메모리의 작은 사각형 하나가 1byte를 의미한다.



- 배열



세 정수를 저장하고 평균을 출력하는 프로그램이 있다.

만약 점수의 개수가 많아진다면 프로그램은 수정할 부분이 많아진다.

이때 활용할 수 있는 것이 배열이다.

배열은 같은 자료형의 데이터를 메모리상에서 연이어서 저장하고 이를 하나의 변수로 관리하기 위해 사용된다.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int scores[3];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // Print average
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
}
```

int scores[3];이라는 코드는 int 자료형을 가지는 크기 3의 배열을 scores라는 이름으로 생성하겠다는 의미이다.

배열의 인덱스는 0부터 시작하기 때문에, scores의 인덱스는 0, 1, 2 세 개이다.

인덱스를 변수명 뒤 대괄호 [] 사이에 입력해 배열의 원하는 위치에 원하는 값을 저장하고 불러올 수 있다.

하지만 위의 코드처럼 배열을 선언하면 요소의 개수가 바뀌는 상황에서 유연하지 못하기 때문에 배열을 동적으로 선언할 수도 있다.



#### 05. 배열(2)



- 전역 변수



만약 N이 고정된 값(상수)라면 그 값을 선언할 때 const를 앞에 붙여 전역 변수, 즉 코드 전반에 거쳐 바뀌지 않는 값임을 지정해줄 수 있다.

관례적으로 전역변수의 이름은 대문자로 표기한다.

```c
const int N = 3;
```



- 배열의 동적 선언 및 저장



```c
#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}
```

다음과 같이 루프와 함수를 선언해 좀 더 동적인 프로그램 작성이 가능하다.

배열의 크기를 사용자에게 입력받고, 배열의 크기만큼 루프를 돌면서 각 인덱스에 해당하는 값을 역시 사용자에게 동적으로 입력받아 저장한다.



#### 06. 문자열과 배열



string 문자열 자료형의 데이터는 사실 char 문자 자료형의 데이터들의 배열이었다.

string s = "Hi!";와 같은 문자열 s는 H(s[0]), I(s[1]), !(s[2]), \0(s[3])로 표현 가능하고, 인덱스로 각 문자에 접근할 수 있다.

여기서 가장 끝의 '\0'은 문자열의 끝을 나타내는 널 종단 문자이다.

단순히 모든 비트가 0인 1바이트를 의미한다.

```c
string names[4];

names[0] = "EMMA"; // E(names[0][0]), M(names[0][1]), M(names[0][2]), A(names[0][3]), \0(names[0][4])
names[1] = "RODRIGO";
names[2] = "BRIAN";
names[3] = "DAVID";

printf("%s\n", names[0]);
printf("%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3]);
```

names라는 문자열 형식의 배열에 네 개의 이름이 저장되어있다.

첫 printf에서는 "EMMA"를 출력, 두 번째 printf에서는 형식지정자가 %c로 설정되어있다.

따라서 문자열이 아닌 문자를 출력한다.

만일 각 이름의 두 번째 문자를 출력하고 싶을 땐, 2차원 배열을 사용해 접근할 수 있다.



#### 07. 문자열의 활용



- 문자열의 길이 및 탐색



사용자로부터 문자열을 입력받아 한 글자씩 출력하는 프로그램을 만들어보자.

for문을 사용해 인덱스를 증가시키면서 해당 문자를 출력하면 된다.

문자열의 끝은 해당 인덱스 문자가 널 종단 문자, '\0'와 일치하는지 검사하면 된다.

하지만 아래 코드와 같이 strlen()이라는 함수를 사용할 수도 있다.

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Input: ");
    printf("Output:\n");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c\n", s[i]);
    }
}
```

strlen 함수는 문자열 길이를 알려주며, string.h 라이브러리 안에 포함되어 있다.

위 코드에서는 n이라는 변수에 문자열 s의 길이를 저장하고, 해당 길이 만큼만 for 루프를 순환하기 때문에 일일이 널 종단 문자를 검사하는 것보다 훨씬 효율적이다.



- 문자열 탐색 및 수정



사용자로부터 문자열을 입력받아 대문자로 바꿔주는 프로그램은 아래와 같이 작성 가능하다.

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        if (s[i] >= 'a' && s[i] <= 'z')
        {
            printf("%c", s[i] - 32);
        }
        else
        {
            printf("%c", s[i]);
        }
    }
    printf("\n");
}
```

문자를 받으면 소문자인지 검사하고, ASCII 값은 대소문자가 32씩 차이나기 때문에 소문자에서 32를 뺀 후 문자 형채로 출력하면 대문자가 출력된다.

이와 동일한 작업을 구행하는 함수는 ctype 라이브러리의 toupper()라는 함수이다.

이를 이용해 아래와 같이 간단하게 작성 가능하다.

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c", toupper(s[i]));
    }
    printf("\n");
}
```



#### 08. 명령행 인자



main 함수의 매개변수를 argc, argv라고 정의해보자.

```c
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
    if (argc == 2)
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
```

첫 번째 인수 argc는 main 함수가 받게 될 입력의 개수이다.

그리고 argv[]는 그 입력이 포함되어 있는 배열이다.

프로그램을 명령행에서 실행하므로, 입력은 문자열로 주어진다.

따라서 argv[]는 string 배열이다.

argv[0]은 기본적으로 프로그램의 이름이다.

만약 하나의 입력이 더 주어진다면 argv[1]에 저장될 것이다.