#### 2-1 자바 프로그램의 구조



- 클래스 만들기

클래스를 만들고, 그 안에 변수, 상수, 함수(메소드) 등 모든 프로그램 요소를 작성한다. 클래스 바깥에 어떤 것도 작성해서는 안 된다. 



```java
public class Hello{
...
}
```



public은 자바의 접근지정자(access specifier)로서 다른 모든 클래스에서 클래스 Hello를 자유롭게 사용할 수 있다는 선언이다



- 주석문

// -> 한 라인 주석문

/* ~ */ -> 여러 라인 주석문



- main() 메소드

자바 프로그램은 main() 메소드부터 실행을 시작한다. main()은 반드시 public static void 타입으로 선언되어야 하며, 한 클래스에 2개 이상의 main()을 작성하면 안 된다.



```java
public static void main(String[] args){
...
}
```



- 메소드

클래스의 멤버 함수를 자바에서는 메소드라고 부른다. 메소드 개수에는 제한이 없다.



```java
public static int sum(int n, int m){
return n + m;
}
```



다음은 메소드 sum()을 호출하는 코드이다.



```java
int i = 20;
s = sum(i, 10);
```



- 변수 선언



변수(variable)란 프로그램 실행 동안 데이터를 저장하는 공간이다.



```java
int i = 10;
char a;
```



메소드 내에 선언되어 사용되는 변수를 지역변수(local variable)라고 한다. 지역 변수는 메소드 내에서만 사용되며, 메소드의 실행이 끝나면 소멸된다.



- 화면 출력



System.out.println()이나 System.out.print()를 이용해서 데이터를 출력한다. println()은 출력 후 다음 행으로 이동하고, print()는 다음 줄로 넘어가지 않는다.



```java
System.out.println("Hello");
System.out.print(2);
```



#### 2.2 식별자



- 식별자

식별자(identifier)란 클래스, 변수, 상수, 메소드 등에 붙이는 이름을 말한다.



- 식별자 이름 규칙

1. 특수문자, 공백은 식별자로 사용할 수 없으나 '_', '$'는 예외로 사용할 수 있다.
2. 한글도 식별자로 사용 가능하다.
3. 자바 언어의 키워드는 식별자로 사용할 수 없다.
4. 식별자의 첫 번째 문자로 숫자 사용할 수 없다.
5. 대소문자를 구별한다.
6. 길이 제한이 없다.



#### 2.3 자바의 데이터 타입



- 기본 타입(basic type) : 8개

  - boolean
  - char
  - byte
  - short
  - int
  - long
  - float
  - double

  

- 레퍼런스 타입(reference type) : 1개

  - 배열에 대한 레퍼런스
  - 클래스에 대한 레퍼런스
  - 인터페이스에 대한 레퍼런스

  

- 레퍼런스



C/C++의 포인터와 비슷한 개념이다. 그러나 C/C++와 달리 실제 주소 값을 가지지 않는다. 지금은 다만 배열에 대한 주소 값 정도, 객체에 대한 주소 값 정도로 생각하고 넘어가자.



- 문자열



자바에서 문자열은 기본 타입에 속하지 않는다. JDK에서 제공하는 String 클래스를 이용한다.



```java
String toolName = "JDK";
```



자바에서는 다음과 같이 문자열과 기본 타입의  + 연산이 실행되면, 기본 타입의 값이 문자열로 바뀌고 두 문자열이 연결된 새로운 문자열이 생성된다.



```java
System.out.println(toolName + "이 출시됨"); // "JDK이 출시됨" 출력
```



- 변수와 선언



변수는 데이터를 저장하는 공간이다. 변수를 선언하면 타입 크기의 메모리가 할당되며, 프로그램은 실행 중에 값을 쓰고 읽는 공간으로 사용한다. 선언과 동시에 초기화가 가능하며 변수를 선언한 후에는 다음과 같이 변수에 값을 저장하고 읽을 수 있다.



- 리터럴(literal)



리터럴이란 프로그램에 직접 표현한 값을 말한다. 정수, 실수, 문자, 논리, 문자열 타입 모두 리터럴이 있으며, 예를 들면 다음과 같다.



```java
34, 42.195, '%', true, "hello"
```



- 정수 리터럴



| 유형   | 설명                   | 사례               |
| ------ | ---------------------- | ------------------ |
| 10진수 | 0으로 시작하지 않는 수 | 15 -> 10진수 15    |
| 8진수  | 0으로 시작하는 수      | 015 -> 십진수 13   |
| 16진수 | 0x로 시작하는 수       | 0x15 -> 십진수 21  |
| 2진수  | 0b로 시작하는 수       | 0b0101 -> 십진수 5 |



- 실수 리터럴



소수점 형태나 지수(exponent) 형태로 실수를 표현한 값이다. 실수 리터럴은 double 타입으로 자동 처리되며, 변수와 함께 쓰면 다음과 같다.



```java
double d = 0.1234;
double e = 1234E-4; // 1234E-4 = 1234 * 10^-4이므로 0.1234와 동일
```



숫자 뒤에 f나 F를 붙이면 float, d나 D를 붙이면 double 타입으로 강제 변환할 수 있다.



```java
float f = 0.1234f;
double w = .1234D;
```



- 문자 리터럴



단일 인용부호(' ')로 문자를 표현하거나 \u 다음에 문자의 유니코드 값을 사용하여 표현한다.



```java
'w', 'A', '글', \u0041
```



<tip>

1. null 리터럴

null은 기본타입에 사용될 수 없고 객체 레퍼런스에 대입된다.

```java
int n = null; // 오류. 기본타입에 null 값 지정 불가능
String str = null; // 정상
```

2. 문자열(String) 리터럴

문자열 리터럴은 이중 인용부호를 이용해 표현한다.

3. Java 10부터 var 키워드를 사용하면 변수 타입 생략

```java
var price = 200; // int 타입으로 결정
var name = "kitae"; // String 타입으로 결정
var pi = 3.14; // double 타입으로 결정
```

하지만, 변수 선언문에 초깃값이 주어지지 않으면 오류가 발생한다. 또한, var의 사용은 지역변수에만 한정된다.

```java
var name; // 컴파일 오류. 변수 name의 타입을 추론할 수 없음
```



- 상수



final 키워드를 사용해 상수를 만든다. 상수는 읽기 전용이라고 생각하면 편하다. 실행 중에 값을 바꿀 수 없다. 



```java
final double PI = 3.141592;
```



- 타입 변환



변수나 상수 혹은 리터럴의 타입을 다른 타입으로 바꾸는 것을 말한다.



- 자동 타입 변환



치환문(=)이나 수식 내에서 타입이 일치하지 않을 때, 컴파일러는 오류 대신 작은 타입을 큰 타입으로 자동 변환한다.



```java
long m = 25; // 리터럴 25는 int 타입. 25가 long 타입으로 자동 변환
double d = 3.14 * 10; // 실수 연산을 하기 위해 10이 10.0으로 자동 변환
```



- 강제 타입 변환



개발자가 강제로 타입 변환을 지시하는 경우이다.



```java
int n = 300;
byte b = n; // 컴파일 오류. int 타입은 byte 타입으로 자동 변환 안 됨
byte b = (byte)n; // n을 byte 타입으로 강제 변환. b = 44
```



300은 byte 타입 (0-255 범위)의 범위보다 크기 때문에, 컴파일러가 자동 변환을 하게 되면, b에 300이 저장되지 않고 256을 뺀 나머지 (300 % 256 = 44) 값 44가 저장된다. 이처럼 큰 타입의 값을 작은 타입의 값으로 변환해야 할 때, 컴파일러는 자동 변환 대신 컴파일 오류를 발생시킨다. 하지만 강제 변환을 하면 데이터 손실이 발생한다.



```java
double d = 1.9;
int n = (int)d; // 강제 타입 변환으로 n은 1이 됨
```



1.9에서 소수점을 잘라버린 듯.



