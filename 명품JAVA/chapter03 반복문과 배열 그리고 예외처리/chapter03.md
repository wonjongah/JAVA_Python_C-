## 반복문과 배열 그리고 예외 처리



------



#### 3.1 반복문



- for 문



```java
for(초기문; 조건식; 반복 후 작업){
... 작업문 ...
}
```



초기문은 조건식에서 사용하는 변수를 초기화한다. 

초기문은 시작할 때만 한 번 수행된다. 콤마로 분리하여 여러 문장을 나열할 수 있다. 초기문은 빈 상태로 두어도 되지만 세미콜론(;)은 있어야 한다.



조건식에는 논리형 변수나 논리 연산을 사용한다.

조건식의 결과가 true이면 반복이 계속되고, false이면 for 문을 벗어난다. 조건식에 true가 있거나 비어있으면 무한반복 된다.



반복 후 작업은 작업문이 실행된 후 실행된다. 



작업문은 for 문이 반복되는 동안 반복 실행된다.



- 반복문에 변수 선언



```java
for(int i = 0; i < 10; i++){ // 변수 i는 for 문 밖에서 사용 불가
System.out.print(i);
}
```



변수 i를 for 문 블록 내에서만 사용되는 지역 변수로 선언하여 사용할 수 있다. 이때 변수 i는 for문 밖에서는 사용 불가하다.



- while 문



```java
while(조건식){
... 작업문 ...
}
```



while 문은 반복 횟수를 알 수 없는 경우에 적합하다. for문과 다르게, while 문에 조건식이 없으면 컴파일 오류가 발생한다. 

while 문을 사용할 때, 조건식의 변수를 while 문 밖에 초기화하는 것, 반복이 진행되면서 조건식이 false가 되어 반복문을 빠져나오게 설계하는 것을 잊지 말아야 한다.



- do-while문



```java
do{
...작업문...
}while(조건식);
```



do-while 문의 조건식은 while 문과 동일하며 조건식이 없으면 컴파일 오류가 발생한다. 다른 반복문과 달리, do-while 문은 작업문 실행 후 조건식을 검사하므로 작업문이 최초 한 번은 반드시 실행된다.

do-while 문의 조건식에 사용되는 변수는 do-while 문 이전에 반드시 초기화가 되어 있어야 하며, 무한 반복에 빠지지 않도록 설계해야 한다.



for 문 -> 반복 횟수와 범위가 명확한 경우

while or do-while 문 -> 반복 횟수를 처음부터 알 수 없고, 반복이 진행되면서 평가되어야 하는 경우



- 중첩 반복



반복 안의 반복을 중첩 반복(nested loop라고 한다. 



#### 3.2 continue 문과 break 문



반복문 내에 continue 문과 break 문을 이용해 반복의 흐름을 바꾸거나 반복에서 벗어나게 할 수 있다.



- continue 문



```java
continue;
```



for 문 -> continue를 만나면 반복 후 작업으로 간다.

while 문 -> 조건식으로 간다.

do-while문 -> 조건식으로 간다.



- break 문



break 문은 하나의 반복문을 즉시 벗어날 때 사용하며 다음과 같이 사용한다.



```java
break;
```



break 문은 하나의 반복문만 벗어난다. 따라서 중첩 반복의 경우 안쪽 반복문만 벗어난다. 



#### 3.3 배열



배열(array)은 인덱스(index)와 인덱스에 대응하는 데이터들로 이루어진 연속적인 자료구조로 같은 종류의 데이터들이 순차적으로 저장된다.



- 배열 선언 및 생성



자바에서 배열의 생성은 C/C++와 달리 두 단계를 거친다.

1. 배열에 대한 레퍼런스 변수 선언 

```java
int intArray []; // 배열의 레퍼런스 변수 intArray 선언
```

배열을 가리킬 변수 선언

2. 배열 생성 - 배열의 저장 공간 할당

```java
intArray = new int[5]; // 데이터를 저장할 배열 공간 할당
```



- 배열의 레퍼런스 변수 선언



```java
int intArray []; // 배열의 레퍼런스 변수 intArray 선언
```

이 선언만으론 배열 공간 할당은 되지 않는다. 배열 공간의 주소 값(레퍼런스 값)을 가지며 그 자체가 배열은 아니다. 아직 배열 공간이 생성되지 않았으므로 intArray는 null을 가진다.

```java
int intArray[];
int [] intArray;
```

위와 같이 두 가지 방법으로 배열의 레퍼런스 변수를 선언할 수 있다.



- 배열 선언 시 []에 크기를 지정하면 안 된다



배열 선언 시 []안에 배열의 크기를 지정하면 컴파일 오류가 난다.

```java
int intArray[10]; // 컴파일 오류
```



- 배열 생성



데이터를 저장할 데이터를 저장할 배열 공간을 할당받는 과정이다. new 연산자를 이용하여 배열을 생성하고 [] 안에 생성할 원소 개수를 지정한다.

```java
intArray = new int[5]; // 정수 5개의 배열 공간 할당받고, 이 배열의 레퍼런스 값을 intArray에 저장
```

이 두 과정을 통해 intArray를 배열로 사용할 수 있다.



- 배열의 선언과 동시에 생성



```java
int intArray[] = new int[5];
```



- 배열 초기화



배열 선언문에서 {}에 원소를 나열하면 초기화된 배열을 만들 수 있다. 

```java
int intArray[] = {4, 3, 2, 1, 0};
double doubleArray[] = {0.1, 2.3, 0.03};
```

intArray 배열의 크기는 자동으로 5가 되며, doubleArray 배열의 크기는 자동으로 3이 된다. 생성되는 배열의 원소 개수는 {}에 나열된 값의 개수로 정해지므로 []에 크기를 주어선 안 된다.



- 배열 인덱스와 배열 원소 접근



배열의 인덱스는 정수만 가능하다. 인덱스는 0부터 시작하며 마지막 원소의 인덱스는 (배열 크기 -1)이다. 배열의 원소를 인덱스를 이용해 접근 가능하다.

```java
int intArray[] = new int[5];
intArray[0] = 5; // 원소 0에 5 저장
intArray[3] = 6;
int n = intArray[3]; //원소 3의 값을 읽어 n에 저장, n은 6이 된다.
```

```java
n = intArray[-2]; // error, 인덱스로 음수 사용 불가
n = intArray[5]; // error, 5는 인덱스 범위(0~4) 넘어섬
```

인덱스는 음수 사용 불가, 또한 배열의 범위를 넘어서 접근한 경우도 에러가 난다.

```java
int intArray []; // 레퍼런스만 선언
intArray[1] = 8; // error, 생성되지 않은 배열 사용
```



- 레퍼런스 치환과 배열 공유



자바에서 레퍼런스 변수와 배열 공간이 분리되어 있기 때문에, 다수의 레퍼런스 변수가 하나의 배열 공간을 가리키는 배열 공유가 쉽게 이루어진다.

```java
int intArray[] = new int[5];
int myArray[] = intArray; // 레퍼런스 치환, myArray는 intArray와 동일한 배열 참조
```

레퍼런스 치환으로 두 레퍼런스가 하나의 배열 공유하는 모습.

intArray 배열을 복사한 것이 아니라, 배열의 주소만 복사된다. myArray는 intArray와 동일한 레퍼런스 값을 갖게 되어 myArray는 intArray의 배열을 공유하게 되고, 배열의 원소 또한 접근 가능하다.



- 배열의 크기, length 필드



자바는 배열을 객체로 다룬다. 배열이 생성되면 객체가 생성된다. 이 객체에는 배열의 저장 공간과 함께 배열의 크기 값을 가진 length 필드가 존재한다.

```java
int intArray[] = new int[5];
int size = intArray.length; // size는 5
```

배열 객체는 length 필드가 있기 때문에, 프로그램에서 배열 크기를 따로 관리하지 않아도 된다.

```java
for(int i = 0; i < intArray.length; i++){ // 배열의 크기만큼 반복하는 코드
System.out.println(intArray[i]);
}
```

위와 같이 유용하게 사용한다.



- 배열과 for-each 문



기존의 for 문을 변형하여, 배열이나 나열(enumeration)의 크기만큼 루프를 돌면서 각 원소를 순차적으로 접근하는데 유용하게 만드는 for 문을 for-each 문이라고 부르며, 구조는 다음과 같다.

```java
for(변수 : 배열레퍼런스){
.. 반복 작업문 ...
}
```

배열 n에 들어있는 모든 정수를 더하는 코드를 for-each 문으로 작성하면 다음과 같다.

```java
int []n = {1,2,3,4,5};
int sum = 0;
for(int k : n){
sum += k;
}
System.out.println("합은 " + sum);
```

앞의 for-each 문은 k = n[0], n[1], n[2], n[3], n[4] 값으로 바꾸면서, 배열 n의 크기만큼 반복한다.

문자열, 나열 타입(enum) 또한 for-each 문을 사용할 수 있다.

```java
String names[] = {"사과", "배", "체리"};
for(String s : names){
System.out.print(s + " ");
}
```

```java
enum Week {월, 화, 수, 목, 금, 토, 일}
for (Week day : Week.values()){
System.out.println(day + "요일 ");
}
```

