## 클래스와 객체



---------



#### 4.1 객체 지향과 자바



- 모든 것이 객체



주변의 모든 것이 객체(object)라고 생각하면 된다.  

실세계의 객체들은 자신만의 고유한 특성(state)과 행동(behavior)을 가지며 다른 객체들에게 행동을 요청하거나 정보를 주고받는 등 상호 작용하면서 존재한다.



- 객체 지향 언어의 특성



객체 지향 언어는 실세계의 객체를 프로그램 내에 표현하기 위해 클래스와 객체 개념을 도입했다.

객체 지향 언어는 다음과 같은 특성을 가진다.



○ **캡슐화(Encapsulation)**



캡슐화란 객체를 캡슐로 싸서 <u>내부를 보호하고 볼 수 없게 하는 것</u>으로 객체의 가장 본질적인 특징이다. 

캡슐 약을 생각하면 이해하기 쉽다.

캡슐에 든 약은 어떤 색인지, 어떤 성분인지 보이지 않으며, 외부의 접근으로부터 안전하다.

예를 들어, 캡슐의 껍질, tv 케이스, 사람의 장기를 보호하는 겉의 피부와 근육을 들어 캡슐화를 생각해볼 수 있다.

객체는 캡슐화가 기본 원칙이지만 외부와의 접속을 위해 <u>몇 부분만 공개노출</u>한다. 

예를 들어, on/off 버튼 노출, 밝기 조절 버튼, 음량 버튼 등과 같이 통신하고 필요한 부분은 노출시킨다.

자바에서 객체는 <u>클래스(class)</u>라는 캡슐을 사용하며, <u>필드(멤버변수)</u>와 <u>메소드(멤버함수)</u>로 구성된다.



○ **상속(Inheritance)**



실세계에서 상속은 상위 개체의 속성이 하위 개체에 물려져서, 하위 개체가 상위 개체의 속성을 모두 가지는 관계이다.

자바의 상속은 <u>자식 클래스가 부모 클래스의 속성을 물려받고 기능을 추가하여 확장(extends)하는 개념</u>이다.

자바에서 부모 클래스를 <u>슈퍼 클래스(super class)</u>라고 부르고, 자식 클래스를 <u>서브 클래스(sub class)</u>라고 부른다.

상속은 슈퍼 클래스의 필드와 메소드를 물려받아 <u>코드를 재사용함으로써, 코드 작성에 드는 시간과 비용을 줄인다.</u>

서브 클래스 객체는 슈퍼 클래스의 멤버와 서브 클래스의 멤버를 모두 가진다.



○ **다형성(Polymorphism)**



다형성은 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것을 말한다.

<u>같은 메소드를 객체에 맞도록 동일한 이름이지만 자신의 특징에 맞게 다시 구현하는 메소드 오버라이딩(overriding)</u>이 한 예다.

<u>다형성의 또 다른 사례로 클래스 내에 이름이 같지만 서로 다르게 동작하는 메소드를 여러 개 만드는 메소드 오버로딩(overloading)</u>이 있다.



- 객체 지향 언어의 목적



객체 지향 언어는 절차 지향 언어의 단점을 보완하고 다음을 보완하고 당므의 목적을 달성하기 위해 탄생했다.

○ 소프트웨어의 생산성 향상

컴퓨터 산업의 발전으로 새로운 소프트웨어를 단 시간 내에 만들어야 했다. 이러한 목적 달성을 위해 객체, 캡슐화, 상속, 다형성 등 소프트웨어의 재사용을 위한 여러 기법을 가진 객체 지향 언어가 탄생했다.

객체 지향 언어는 소프트웨어의 생상성을 향상시킨다.

○ 실세계에서 쉬운 모델링

실세계의 일을 프로그래밍하는 경우가 많아지면서 물체(객체)들의 상호 작용으로 묘사하는 것이 적합하다.

○ 절차 지향 프로그래밍과 객체 지향 프로그래밍

절차 지향 프로그래밍은 목적을 달성하기 위한 일의 흐름에 중점을 둔다.

객체 지향 프로그래밍은 실제 세상에 가깝게 모델링해 실제 세상의 물체를 객체로 표현하고, 객체들의 관계, 상호 작용을 설계한 뒤, 각 객체를 클래스로 작성하면 프로그램이 완성된다.



#### 4.2 자바 클래스 만들기



- 클래스와 객체



클래스는 객체를 만들어내기 위한 설계도 혹은 틀이며, 클래스 모양 그대로 생성된 실체가 객체이다.

이러한 연유로 객체를 클래스의 인스턴스(instance)라고도 부른다.

클래스는 하나이지만 객체들은 수 없이 많이 생성될 수 있다. 객체들은 클래스의 모양대로 모두 동일한 속성을 가지고 탄생하지만, 자신만의 고유한 값을 가짐으로써 구분된다. 객체들마다 속성의 값은 서로 다르다.



- 클래스 구성



자바 클래스는 class 키워드를 사용해 선언한다.

클래스의 구성 요소를 멤버라고 부르며, 멤버는 필드(멤버 변수)와 메소드(멤버 함수) 두 가지이다.

```java
public class Circle{
public int radius; // 원의 반지름 필드
public String name; // 원의 이름 필드
// 위의 두 줄이 필드(변수)
    
public Circle(){ // 원의 생성자 메소드
}
public double getArea(){ // 원의 면적 계산 메소드
return 3.14 * radius * radius;
}
// 위의 네 줄이 메소드
}
```



1. 클래스 선언, class Circle

이 코드는 이름이 Circle인 클래스를 선어한다. class 키워드와 클래스 이름으로 선언하고 중괄호{} 안에 필드와 메소드를 모두 작성한다. 클래스 외부에는 캡슐화의 원칙으로 어떤 필드나 메소드를 둘 수 없다.

2. 필드와 메소드

객체 내에 값을 저장할 멤버 변수를 필드라고 부른다. Circle 클래스에는 radius와 name 두 필드가 있다.

메소드는 함수이며 객체의 행동을 구현한다. 

3. 접근 지정자, public

Circle이나 필드, 메소드에 붙은 public을 접근 지정자라고 한다. public은 다른 클래스에서 활용하거나 접근할 수 있음을 선언한다.

4. 생성자(constructor)

<u>클래스의 이름과 동일한 메소드를 특별히 생성자(constructor)라고 한다.</u>

<u>생성자는 객체가 생성될 때 자동으로 호출되는 특별한 메소드이다.</u>

 

- new 연산자와 객체 생성, 그리고 레퍼런스 변수



```java
public class Circle{
public int radius; // 원의 반지름 필드
public String name; // 원의 이름 필드
// 위의 두 줄이 필드(변수)
    
public Circle(){ // 원의 생성자 메소드
}
public double getArea(){ // 원의 면적 계산 메소드
return 3.14 * radius * radius;
}
// 위의 네 줄이 메소드
}

public static void main(String args[]){
Circle pizza; // Circle 객체에 대한 레퍼런스 변수 pizza 선언, 변수만 생성, 아직 가리키지 않음
pizza = new Circle(); // 객체 메모리 할당 및 Circle 객체 생성, 레퍼런스 변수 가리키도록.

pizza.radius = 10; // radius 필드에 10 저장
pizza.name = "자바피자"; // name 필드에 "자바피자" 저장
double area = pizza.getArea(); // pizza 객체의 면적 알아내기
}
```



1. Circle pizza; 

Circle 객체의 레퍼런스 변수 생성, 변수만 생성된 것이지 아직 객체를 가리키지 않는다.

2. pizza = new Circle(); 

객체 메모리 할당(객체에게 한 방을 주었다고 생각) + 레퍼런스 변수 pizza가 이 객체 가리키도록 지정.

3. pizza.radius = 10; pizza.name = "자바피자";

radius와 name 값 변경

4. double area = pizza.getArea();

getArea() 메소드 실행해 pizza 객체의 면적 알아내기